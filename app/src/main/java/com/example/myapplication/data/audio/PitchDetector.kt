package com.example.myapplication.data.audio

import kotlin.math.abs

// –û–±—ä–µ–∫—Ç –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —á–∞—Å—Ç–æ—Ç—ã (pitch) –∑–≤—É–∫–∞ –∏–∑ –º–∞—Å—Å–∏–≤–∞ PCM –¥–∞–Ω–Ω—ã—Ö
object PitchDetector {

    /**
     * –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —á–∞—Å—Ç–æ—Ç—É —Å–∏–≥–Ω–∞–ª–∞ –≤ –ì—Ü –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–∞—Å—Å–∏–≤–∞ PCM –¥–∞–Ω–Ω—ã—Ö.
     *
     * @param buffer –ú–∞—Å—Å–∏–≤ PCM –¥–∞–Ω–Ω—ã—Ö (ShortArray) —Å –∞—É–¥–∏–æ-—Å–∏–≥–Ω–∞–ª–æ–º.
     * @param sampleRate –ß–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏ –∞—É–¥–∏–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 44100 –ì—Ü).
     * @return –ß–∞—Å—Ç–æ—Ç–∞ —Å–∏–≥–Ω–∞–ª–∞ –≤ –ì—Ü, –∏–ª–∏ 0.0 –µ—Å–ª–∏ —á–∞—Å—Ç–æ—Ç–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞.
     */
    fun detectFrequency(buffer: ShortArray, sampleRate: Int): Double {
        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º ShortArray –≤ FloatArray –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π
        val floats = buffer.map { it.toFloat() }.toFloatArray()
        val n = floats.size  // –î–ª–∏–Ω–∞ –±—É—Ñ–µ—Ä–∞

        var bestLag = 0      // –õ–∞–≥ (—Å–¥–≤–∏–≥), –∫–æ—Ç–æ—Ä—ã–π –¥–∞—ë—Ç –Ω–∞–∏–±–æ–ª—å—à—É—é –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—é
        var bestCorr = 0.0   // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏

        // üîπ –ê–ª–≥–æ—Ä–∏—Ç–º –∞–≤—Ç–æ–∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏:
        // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å–∏–≥–Ω–∞–ª —Å —Å–∞–º–∏–º —Å–æ–±–æ–π —Å–æ —Å–¥–≤–∏–≥–æ–º lag.
        // –ß–µ–º –≤—ã—à–µ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è, —Ç–µ–º –≤–µ—Ä–æ—è—Ç–Ω–µ–µ, —á—Ç–æ —ç—Ç–æ –ø–µ—Ä–∏–æ–¥ —Å–∏–≥–Ω–∞–ª–∞.
        for (lag in 20..(n / 2)) { // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–∏–µ –ª–∞–≥–∏ (20) –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —à—É–º–æ–≤
            var corr = 0.0
            // –í—ã—á–∏—Å–ª—è–µ–º –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—é –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ lag
            for (i in 0 until n - lag) {
                corr += floats[i] * floats[i + lag]
            }
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º lag —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–µ–π
            if (corr > bestCorr) {
                bestCorr = corr
                bestLag = lag
            }
        }

        // üîπ –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–π –ª–∞–≥ –≤ —á–∞—Å—Ç–æ—Ç—É:
        // –ß–∞—Å—Ç–æ—Ç–∞ = sampleRate / –ø–µ—Ä–∏–æ–¥ (lag)
        // –ï—Å–ª–∏ bestLag = 0 (–Ω–µ –Ω–∞–π–¥–µ–Ω–æ), –≤–æ–∑–≤—Ä–∞—â–∞–µ–º 0
        return if (bestLag != 0) sampleRate.toDouble() / bestLag else 0.0
    }
}
